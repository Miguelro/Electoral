{
    "collab_server" : "",
    "contents" : "# Funciones para Reparto de Escaños\n\n# Función para metodo restos mayores\n#'@title Método restos mayores\n#'\n#'\n#'@description Esta función sirve para traducir una serie de votos\n#'en escaños, siguiendo el criterio denominado \"Restos mayores\". De forma\n#'resumida este método se calcula de la sigueinte forma: se divide el\n#'número total de votos entre los escaños totales ( costo de cada escaño ).\n#'Después se dividen los votos de cada partido entre el cociente anterior.\n#'Se toman las partes enteras de los resultados anteriores que serán\n#'los escaños iniciales que corresponde a cada partido. El resto de\n#'escaños hasta completar los que hay que repartir, se asigna a los\n#'partidos que tengan los restos más altos ( ver https://es.wikipedia.org/wiki/M%C3%A9todo_del_resto_mayor).\n#'\n#'El costo de cada escaño es lo que diferencia a unos métodos de otros.\n#'De esta manera si n es el total de escaños y m la suma de todos los votos,\n#'la denominación de los métodos  es la siguiente, dependiendo del\n#'cociente que se tome:\n#'\n#'- Hare: q=m/n\n#'- Droop: q=1+(m/(1+n))\n#'- Imperiali: q=m/(n+2)\n#'- Imperiali modificado: q=m/(n+3)\n#'- Hangenbach Bischof: q=m/(n+1)\n#'\n#'En todos los caso el valor de q se redondea al entero más proximo\n#'\n#'\n#'@param partidos  Un vector de texto conteniendo el nombre de los partidos\n#'@param votos Un vector de números enteros, con los votos de cada partido\n#'@param escanos un número entero conteniendo el total de escaños a repartir\n#'@param método Es el método a utilizar los valores admitidos son\n#'  c(\"Hare\",\"Droop\",\"Imperiali\",\"Mod_Imperiali\",hangenbach-bischo\").\n#'  El valor por defecto es \"Hare\"\n#'\n#'\n#'@return Dataframe con los partidos políticos y los votos asignados\n#'\n#'@import readxl\n#'\n#'@example\n#'Restos_Mayores(c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"),\n#'  c(391000,311000,184000,73000,27000,12000,2000),\n#'  21,metodo = \"Imperiali\")\n#'\n#'\n#'@export\nRestos_Mayores<-function(partidos,votos,escanos,metodo=\"Hare\"){\n  if(length(partidos)!=length(votos)) stop(\"Dimensión vector partidos, debe ser igual a la dimensión\n                                           del vector votos\")\n  if(escanos<=0) stop(\"El número de esaños debe ser mayor o igual que 1\")\n\n  if(!(metodo %in% c(\"Hare\",\"Droop\",\"Imperiali\",\"Mod_Imperiali\",\n                     \"hangenbach-bischo\")))\n  {\n    stop(\"Método inválido\")\n  }\n  tvotos<-sum(votos) # total de votos\n  # Claculo del valor de q\n  if(metodo == \"Hare\"){\n    cociente=round(tvotos/escanos,0)\n  }else if(metodo ==\"Droop\"){\n    cociente=round(1+(tvotos/(1+escanos)),0)\n  }else if(metodo == \"Imperiali\"){\n    cociente=round(tvotos/(escanos+2),0)\n  }else if(metodo == \"Mod_Imperiali\"){\n    cociente=round(tvotos/(escanos+3),0)\n  }else if(metodo == \"hangenbach-bischo\"){\n    cociente=round(tvotos/(escanos+1),0)\n  }\n\n  # Tomo la parte entera\n  ente<-floor(votos/cociente)\n  # tomo la parte decimal\n  frac<-(votos/cociente)-ente\n\n  Entera<-data.frame(parti=partidos,esca=ente)\n  Fracional<-data.frame(parti=partidos,fra=frac)\n  # Calculo resto de escaños quedan a repartir\n  #por la parte fraccionaria\n  resto_escanos<-escanos-sum(Entera$esca)\n  Fracional<-Fracional[order(-Fracional$fra),][1:resto_escanos,]\n  # Asigno un escaño partidos con mayor resto\n  Fracional$fra<-1\n  Total<-merge(Entera,Fracional,all.x=T)\n  # Obtengo escaños finales\n  Total$escaT<-apply(Total[,2:3],1,sum,na.rm=T)\n  return(Total[,c(1,4)])\n}\n\nRestos_Mayores(c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"),\n               c(391000,311000,184000,73000,27000,12000,2000),\n               21,metodo = \"Imperiali\")\n\n\n\n#### Ley d'Hondt. Esta función no va al paquete\ndHont<-function(candidaturas,votos,escanos){\n  tmp<-data.frame(\n    candi<-rep(candidaturas,each=escanos),\n    scor<-as.vector(sapply(votos,function(x) x/1:escanos))\n  )\n  tmp<-tmp$candi[order(-tmp$scor)][1:escanos]\n  return(table(tmp))\n}\n\ndHont(c(\"A\",\"B\",\"C\"),c(25000,16000,9000),5)\n\n# esto sí va al paquete\n# Repartos por cocientes\n# Esta función la utilizo de apoyo\n# Sirve para hacer las divisiones, dependiendo del método usado\ncoci<-function(x,metodo,escanos){\n  if(metodo == \"dhondt\"){\n    a<- seq.int(1,escanos)\n    #re<-x/seq.int(1,escanos)\n  }\n  else if(metodo == \"saint_lague\"){\n    # Calculo secuencia divisores y me quedo con tantos\n    #como indique la variable escanos\n    a<- seq.int(1,4*escanos,by=2)[1:escanos]\n    #re<-x/a\n  }\n  else if(metodo==\"saint_lague_Mod\"){\n    a<-c(1.4,seq.int(3,4*escanos,by=2))[1:escanos]\n    re<-x/a\n  }else if(metodo==\"Danish\"){\n    a<-seq.int(1,4*escanos,by=3)[1:escanos]\n  }\n  else if(metodo==\"Imperiali\"){\n    a<-seq.int(2,escanos+1)[1:escanos]\n  }\n  else if(metodo==\"Hill_Huntington\"){\n    a1<-1:escanos\n    a2<-2:(escanos+1)\n    a<-sqrt(a1*a2)\n  }\n  else if(metodo==\"Dean\"){\n    a1<-1:escanos\n    a2<-2:(escanos+1)\n    a11<-(2*a1)*a2\n    a22<-2*a1+1\n    a<-a11/a22\n  }\n\n  # Calculo el valor de las divisiones\n  re<-x/a\n  return(re)\n}\n\n#Función con los métodos de los divisores\n#'@title Reparto métodos divisores\n#'\n#'\n#'@description Con esta opción se utiliza diversos métodos que tienen\n#'Como carcaterística principal que el número de votos obtenidos por\n#'\n#'En todos los caso el valor de q se redondea al entero más proximo\n#'\n#'\n#'@param partidos  Un vector de texto conteniendo el nombre de los partidos\n#'@param votos Un vector de números enteros, con los votos de cada partido\n#'@param escanos un número entero conteniendo el total de escaños a repartir\n#'@param método Es el método a utilizar los valores admitidos son\n#'  c(\"Hare\",\"Droop\",\"Imperiali\",\"Mod_Imperiali\",hangenbach-bischo\").\n#'  El valor por defecto es \"Hare\"\n#'\n#'\n#'@return Dataframe con los partidos políticos y los votos asignados\n#'\n#'@import readxl\n#'\n#'@example\n#'Restos_Mayores(c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"),\n#'  c(391000,311000,184000,73000,27000,12000,2000),\n#'  21,metodo = \"Imperiali\")\n#'\n#'\n#'@export\nreparto_div<-function(candidaturas,votos,escanos,metodo){\n  # Primero compruebo que el método existe\n  if(!(metodo %in% c(\"dhondt\",\"saint_lague\",\"saint_lague_Mod\",\n                     \"Danish\",\"Imperiali\",\"Hill_Huntington\",\n                     \"Dean\"))){\n    stop(\"El método solicitado no está implementado en esta función\")\n  }\n  scor2<-as.vector(sapply(votos,coci,metodo,escanos))\n\n  tmp<-data.frame(\n    candi = rep(candidaturas,each=escanos),\n    scor = scor2\n  )\n  tmp<-tmp$candi[order(-tmp$scor)][1:escanos]\n  r <- as.data.frame(table(tmp))\n  colnames(r) <- c(\"Candidatura\", \"Escanos\")\n  return(r)\n\n}\n\n\nA <- reparto_div(c(\"A\",\"B\",\"C\",\"D\"),c(340000,280000,160000,60000),7,metodo=\"dhondt\")\n",
    "created" : 1573296756571.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1758373475",
    "id" : "D5A23EFA",
    "lastKnownWriteTime" : 1573301747,
    "last_content_update" : 1573301747119,
    "path" : "C:/Master_Estad_Apli/TFM/Code/Relectoral/R/Reparto_Escanos.R",
    "project_path" : "R/Reparto_Escanos.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}